#include "AudioEngine.h"
#include <nlohmann/json.hpp>
#include <juce_audio_devices/juce_audio_devices.h>

using json = nlohmann::json;



bool AudioEngine::loadPlugin(const juce::File& file) {
    if (!file.existsAsFile()) return false;
    // Add logic for loading a plugin
    return true; // Return true if successful
}

bool AudioEngine::savePreset(const juce::File& file) {
    if (!file.hasWriteAccess()) return false;
    // Add logic for saving a preset
    return file.create(); // Example: Save to file
}

bool AudioEngine::loadPreset(const juce::File& file) {
    if (!file.existsAsFile()) return false;
    // Add logic for loading a preset
    return true; // Return true if successful
}

nlohmann::json AudioEngine::getDeviceList() {
    nlohmann::json response;

    // Get the list of available device types
    juce::OwnedArray<juce::AudioIODeviceType> types;
    deviceManager.createAudioDeviceTypes(types);  // Ensure deviceManager is not const

    // Iterate through device types
    for (auto* type : types) {
        type->scanForDevices();  // Refresh device list
        auto inputDevices = type->getDeviceNames(true);   // Input devices
        auto outputDevices = type->getDeviceNames(false); // Output devices

        // Convert JUCE StringArray to std::vector<std::string>
        std::vector<std::string> inputs;
        for (const auto& input : inputDevices) {
            inputs.push_back(input.toStdString());
        }

        std::vector<std::string> outputs;
        for (const auto& output : outputDevices) {
            outputs.push_back(output.toStdString());
        }

        // Assign the vectors to JSON
        response["inputs"] = inputs;
        response["outputs"] = outputs;
    }

    return response;
}

nlohmann::json AudioEngine::setInputDevice(const std::string& deviceName) {
    nlohmann::json response;

    juce::AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup(setup);
    setup.inputDeviceName = deviceName;

    auto error = deviceManager.setAudioDeviceSetup(setup, true);
    if (error.isEmpty()) { // No error indicates success
        response["status"] = "success";
        response["message"] = "Input device set successfully";
    } else {
        response["status"] = "error";
        response["message"] = "Failed to set input device: " + error.toStdString();
    }

    return response;
}

nlohmann::json AudioEngine::setOutputDevice(const std::string& deviceName) {
    nlohmann::json response;

    juce::AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup(setup);
    setup.outputDeviceName = deviceName;

    auto error = deviceManager.setAudioDeviceSetup(setup, true);
    if (error.isEmpty()) { // No error indicates success
        response["status"] = "success";
        response["message"] = "Output device set successfully";
    } else {
        response["status"] = "error";
        response["message"] = "Failed to set output device: " + error.toStdString();
    }

    return response;
}
#pragma once
#ifndef AUDIOENGINE_H
#define AUDIOENGINE_H

#include <juce_core/juce_core.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <nlohmann/json.hpp>

class AudioEngine
{
public:
    static AudioEngine& getInstance()
    {
        static AudioEngine instance; // Thread-safe in C++11 and later
        return instance;
    }

    nlohmann::json getDeviceList(); // Ensure this matches the definition in the .cpp file
    nlohmann::json setInputDevice(const std::string& deviceName); // Match this
    nlohmann::json setOutputDevice(const std::string& deviceName); // Match this

    // Other public methods
    bool loadPlugin(const juce::File& file);
    bool savePreset(const juce::File& file);
    bool loadPreset(const juce::File& file);

private:
    AudioEngine() = default; // Private constructor
    ~AudioEngine() = default;

    // Delete copy constructor and assignment operator to prevent copies
    AudioEngine(const AudioEngine&) = delete;
    AudioEngine& operator=(const AudioEngine&) = delete;

    juce::AudioDeviceManager deviceManager; // Example member variable
};

#endif // AUDIOENGINE_H
#ifndef CONFIG_H
#define CONFIG_H
#define JUCE_PLUGINHOST_AU 1
#define JUCE_PLUGINHOST_AU3 1

// Fix for SMTG_CPP20 redefinition warnings
#ifndef SMTG_CPP20
    #define SMTG_CPP20 (__cplusplus >= 202002L)
#endif

#endif // CONFIG_H
<key>UIApplicationExitsOnSuspend</key>
<true/>
<key>NSPersistentUIEnabled</key>
<false/>
<key>NSMicrophoneUsageDescription</key>
<string>This app requires access to the microphone for audio routing.</string>
#include "AudioEngine.h"
#include <JuceHeader.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include "MainComponent.h"


class AudioRouterApp : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "AudioRouterApp"; }
    const juce::String getApplicationVersion() override { return "0.0.1"; }
    bool moreThanOneInstanceAllowed() override { return true; }

    void initialise(const juce::String& commandLine) override
    {
        mainWindow.reset(new MainWindow("AudioRouterApp", new MainComponent(), *this));
        
    }

    void shutdown() override
    {
        mainWindow = nullptr;
    }

private:
    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow(const juce::String& name, juce::Component* c, JUCEApplication& app)
            : DocumentWindow(name, juce::Colours::lightgrey, DocumentWindow::allButtons),
              owner(app)
        {
            setUsingNativeTitleBar(true);
            setContentOwned(c, true);
            centreWithSize(getWidth(), getHeight());
            setVisible(true);
        }

        void closeButtonPressed() override
        {
            JUCEApplication::getInstance()->systemRequestedQuit();
        }

    private:
            JUCEApplication& owner;

            JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

        std::unique_ptr<MainWindow> mainWindow;
};

// Start the JUCE application
START_JUCE_APPLICATION(AudioRouterApp)
#include "MainComponent.h"
#include "AudioEngine.h"

MainComponent::MainComponent()
{
    setLookAndFeel(&customLookAndFeel);
    audioDeviceManager.initialiseWithDefaultDevices(2, 2);
    audioDeviceManager.addChangeListener(this);

    setupDropdown(hardwareInputsMenu, "Hardware Inputs", hardwareInputsLabel);
    setupDropdown(hardwareOutMenu, "Hardware Outputs", hardwareOutLabel);
    setupDropdown(pluginDropdown, "Plugins", pluginLabel);

    addAndMakeVisible(scanPluginsButton);
    scanPluginsButton.onClick = [this]() { scanForPlugins(); };

    changeListenerCallback(&audioDeviceManager);
    setSize(600, 500);
}

MainComponent::~MainComponent()
{
    audioDeviceManager.removeChangeListener(this);
    setLookAndFeel(nullptr);
}

void MainComponent::setupDropdown(juce::ComboBox& dropdown, const juce::String& labelText, juce::Label& label)
{
    addAndMakeVisible(dropdown);
    dropdown.setJustificationType(juce::Justification::centredLeft);

    addAndMakeVisible(label);
    label.setText(labelText, juce::dontSendNotification);
    label.attachToComponent(&dropdown, true);
}

void MainComponent::changeListenerCallback(juce::ChangeBroadcaster* source)
{
    if (source == &audioDeviceManager)
    {
        if (auto* currentDevice = audioDeviceManager.getCurrentAudioDevice())
        {
            populateDropdown(hardwareInputsMenu, currentDevice->getInputChannelNames());
            populateDropdown(hardwareOutMenu, currentDevice->getOutputChannelNames());
        }
    }
}

void MainComponent::populateDropdown(juce::ComboBox& dropdown, const juce::StringArray& items)
{
    dropdown.clear();
    for (int i = 0; i < items.size(); ++i)
        dropdown.addItem(items[i], i + 1);

    if (items.isEmpty())
        dropdown.addItem("No devices available", 1);
}

void MainComponent::scanForPlugins()
{
    juce::StringArray pluginDirectories;

    // Define default plugin directories based on the OS
    #if JUCE_MAC
        pluginDirectories.add("/Library/Audio/Plug-Ins/VST");
        pluginDirectories.add("/Library/Audio/Plug-Ins/VST3");
        pluginDirectories.add("/Library/Audio/Plug-Ins/Components");
        pluginDirectories.add("~/Library/Audio/Plug-Ins/VST");
        pluginDirectories.add("~/Library/Audio/Plug-Ins/VST3");
        pluginDirectories.add("~/Library/Audio/Plug-Ins/Components");
    #elif JUCE_WINDOWS
        pluginDirectories.add("C:\\Program Files\\VSTPlugins");
        pluginDirectories.add("C:\\Program Files\\Common Files\\VST3");
        pluginDirectories.add("C:\\Program Files (x86)\\VSTPlugins");
        pluginDirectories.add("C:\\Program Files (x86)\\Common Files\\VST3");
    #elif JUCE_LINUX
        pluginDirectories.add("~/.vst");
        pluginDirectories.add("/usr/lib/vst");
        pluginDirectories.add("/usr/local/lib/vst");
    #endif

    DBG("Starting plugin scan...");

    // Add formats to the AudioPluginFormatManager
    juce::AudioPluginFormatManager pluginFormatManager;
    pluginFormatManager.addDefaultFormats(); // Adds AU, VST, and VST3 formats by default

    // List of valid file extensions
    juce::StringArray validExtensions { "vst", "vst3", "component" };

    for (const auto& directoryPath : pluginDirectories)
    {
        juce::File directory(directoryPath);
        
        if (!directory.isDirectory())
        {
            DBG("Directory not found: " << directory.getFullPathName());
            continue;
        }
        
        DBG("Scanning directory: " << directory.getFullPathName());
        
        // Use RangedDirectoryIterator for better and modern file iteration
        for (const auto& file : juce::RangedDirectoryIterator(directory, false, "*.*"))
        {
            DBG("Scanning file: " << file.getFile().getFileName());
            
            // Check for plugin validity using extensions
            for (const auto& ext : validExtensions)
            {
                if (file.getFile().hasFileExtension(ext))
                {
                    DBG("Found potential plugin: " << file.getFile().getFullPathName());
                    
                    juce::PluginDescription description;
                    description.fileOrIdentifier = file.getFile().getFullPathName();
                    description.name = file.getFile().getFileName();
                    description.pluginFormatName = "Unknown";
                    
                    juce::String errorMessage;
                    
                    auto plugin = pluginFormatManager.createPluginInstance(
                                                                           description,
                                                                           44100.0, // sample rate
                                                                           512,     // buffer size
                                                                           errorMessage
                                                                           );
                    
                    if (plugin)
                    {
                        DBG("Successfully loaded plugin: " << file.getFile().getFileName());
                        scannedPlugins.add(file.getFile().getFullPathName());
                    }
                    else
                    {
                        DBG("Failed to load plugin: " << file.getFile().getFileName() << " - " << errorMessage);
                    }
                    
                    break; // Exit the loop once a matching extension is found
                }
            }
        }
    }
    populatePluginDropdown();
    DBG("Plugin scan completed.");
}

bool MainComponent::validatePlugin(const juce::File& file)
{
    juce::AudioPluginFormatManager formatManager;
    formatManager.addDefaultFormats();

    DBG("Validating plugin binary: " << file.getFullPathName());

    juce::OwnedArray<juce::PluginDescription> pluginDescriptions;

    for (auto* format : formatManager.getFormats())
    {
        DBG("Trying format: " << format->getName());

        if (format->fileMightContainThisPluginType(file.getFullPathName()))
        {
            try
            {
                DBG("Checking if file might contain a valid plugin: " << file.getFullPathName());
                format->findAllTypesForFile(pluginDescriptions, file.getFullPathName());

                if (!pluginDescriptions.isEmpty())
                {
                    DBG("Plugin is valid: " << pluginDescriptions[0]->name);
                    return true;
                }
                else
                {
                    DBG("No valid plugin descriptions found for: " << file.getFullPathName());
                }
            }
            catch (const std::exception& e)
            {
                DBG("Validation error for " << file.getFullPathName() << ": " << e.what());
            }
            catch (...)
            {
                DBG("Unknown validation error for: " << file.getFullPathName());
            }
        }
        else
        {
            DBG("File does not match format: " << format->getName());
        }
    }

    DBG("Validation failed for plugin binary: " << file.getFullPathName());
    return false;
}

void MainComponent::populatePluginDropdown()
{
    pluginDropdown.clear();

    if (scannedPlugins.isEmpty())
    {
        DBG("No plugins found.");
        pluginDropdown.addItem("No plugins found", 1);
    }
    else
    {
        for (int i = 0; i < scannedPlugins.size(); ++i)
        {
            pluginDropdown.addItem(scannedPlugins[i], i + 1);
        }
    }
}

void MainComponent::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::lightgrey);
}

void MainComponent::resized()
{
    auto area = getLocalBounds().reduced(20);
    auto labelHeight = 20;
    auto dropdownHeight = 30;
    auto buttonHeight = 40;
    auto spacing = 10;

    hardwareInputsLabel.setBounds(area.removeFromTop(labelHeight));
    hardwareInputsMenu.setBounds(area.removeFromTop(dropdownHeight).reduced(0, 5));
    area.removeFromTop(spacing);

    hardwareOutLabel.setBounds(area.removeFromTop(labelHeight));
    hardwareOutMenu.setBounds(area.removeFromTop(dropdownHeight).reduced(0, 5));
    area.removeFromTop(spacing);

    pluginLabel.setBounds(area.removeFromTop(labelHeight));
    pluginDropdown.setBounds(area.removeFromTop(dropdownHeight).reduced(0, 5));
    area.removeFromTop(spacing);

    scanPluginsButton.setBounds(area.removeFromTop(buttonHeight).reduced(0, 5));
}
#pragma once

#include <JuceHeader.h>
#include "AudioEngine.h"

// Custom LookAndFeel class to customize fonts
class CustomLookAndFeel : public juce::LookAndFeel_V4
{
public:
    CustomLookAndFeel()
    {
        setDefaultSansSerifTypefaceName("Arial");
    }

    juce::Font getComboBoxFont(juce::ComboBox&) override
    {
        juce::FontOptions options;
        options = options.withHeight(18.0f);
        return juce::Font(options);
    }

    juce::Font getLabelFont(juce::Label&) override
    {
        juce::FontOptions options;
        options = options.withHeight(18.0f);
        return juce::Font(options);
    }
};

class MainComponent : public juce::Component,
                      public juce::ChangeListener
{
public:
    MainComponent();
    ~MainComponent() override;

    // Component overrides
    void paint(juce::Graphics&) override;
    void resized() override;

    // ChangeListener override
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;

private:
    // Helper functions
    void setupDropdown(juce::ComboBox& dropdown, const juce::String& labelText, juce::Label& label);
    void populateDropdown(juce::ComboBox& dropdown, const juce::StringArray& items);
    void scanForPlugins();                         // Scan for plugins in specified directories
    void populatePluginDropdown();                 // Populate dropdown with plugins
    bool validatePlugin(const juce::File& file);   // Validate the plugin file

    // UI Components
    juce::ComboBox hardwareInputsMenu, hardwareOutMenu, pluginDropdown; // Added `pluginDropdown`
    juce::Label hardwareInputsLabel{"Hardware Inputs"},
                hardwareOutLabel{"Hardware Outputs"},
                pluginLabel{"Plugins"};            // Added `pluginLabel`
    juce::TextButton scanPluginsButton{"Scan Plugins"};
    juce::AudioDeviceManager audioDeviceManager;

    // Custom LookAndFeel
    CustomLookAndFeel customLookAndFeel;           // Added `customLookAndFeel`

    // Scanned plugins
    juce::StringArray scannedPlugins;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainComponent)
};
#include "ZeroMQServer.h"
#include <iostream>

ZeroMQServer::ZeroMQServer() : socket(context, ZMQ_REP)
{
    socket.bind("tcp://*:5555");
}

ZeroMQServer::~ZeroMQServer()
{
    socket.close();
    context.close();
}

void ZeroMQServer::listen()
{
    while (true)
    {
        zmq::message_t request;
        auto result = socket.recv(request, zmq::recv_flags::none);
        if (!result)
        {
            std::cerr << "Failed to receive message from socket." << std::endl;
            return; // Or handle the error appropriately
        }

        try
        {
            std::string msg(static_cast<char*>(request.data()), request.size());
            nlohmann::json command = nlohmann::json::parse(msg);

            // Use the Singleton instance of AudioEngine
            nlohmann::json response = processCommand(command, AudioEngine::getInstance());

            zmq::message_t reply(response.dump());
            socket.send(reply, zmq::send_flags::none);
        }
        catch (const std::exception& e)
        {
            nlohmann::json errorResponse = {
                {"status", "error"},
                {"message", e.what()}
            };

            zmq::message_t reply(errorResponse.dump());
            socket.send(reply, zmq::send_flags::none);
        }
    }
}

nlohmann::json ZeroMQServer::processCommand(const nlohmann::json& command, AudioEngine& audioEngine)
{
    nlohmann::json response;

    if (command.contains("action"))
    {
        std::string action = command["action"];
        if (action == "get_devices")
        {
            return audioEngine.getDeviceList();
        }
        else if (action == "set_input" && command.contains("device_name"))
        {
            return audioEngine.setInputDevice(command["device_name"]);
        }
        else if (action == "set_output" && command.contains("device_name"))
        {
            return audioEngine.setOutputDevice(command["device_name"]);
        }
    }

    response["status"] = "error";
    response["message"] = "Unknown or invalid command";
    return response;
}
#ifndef ZEROMQ_SERVER_H
#define ZEROMQ_SERVER_H

#include <nlohmann/json.hpp>
#include <zmq.hpp>
#include <string>
#include "AudioEngine.h"

class ZeroMQServer
{
public:
    ZeroMQServer();
    ~ZeroMQServer();

    void listen();

private:
    nlohmann::json processCommand(const nlohmann::json& command, AudioEngine& audioEngine);

    zmq::context_t context{1};
    zmq::socket_t socket;
};


#endif // ZEROMQ_SERVER_H
